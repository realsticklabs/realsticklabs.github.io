<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three Block</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #saveButton {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px 20px;
            background-color: #0078D7;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 16px;
        }
        #saveButton:hover {
            background-color: #005fa3;
        }
    </style>
</head>
<body>
    <button id="saveButton">Save Level</button>
    <script>
        // Scene setup
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const blockSize = 3;

        // Platform (Ground)
        const platformGeometry = new THREE.BoxGeometry(blockSize, blockSize / 2, blockSize);
        const platformMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
        const platform = new THREE.Mesh(platformGeometry, platformMaterial);
        platform.position.set(0, -blockSize / 4, 0);
        scene.add(platform);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xffffff, 1);
        pointLight.position.set(10, 10, 10);
        scene.add(pointLight);

        // Blocks array
        const blockGeometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
        const blockColors = [0xff0000, 0xff7f00, 0xffff00, 0x00ff00, 0x0000ff, 0x4b0082, 0xff1493];
        let currentBlockColor = blockColors[0];
        const blocks = [platform];

        // Player setup (camera)
        const velocity = new THREE.Vector3(); // For movement
        const direction = new THREE.Vector3(); // For direction
        camera.position.set(0, blockSize, 5);
        camera.lookAt(0, 0, 0);

        // Block placement helper
        function isAdjacent(position) {
            const directions = [
                new THREE.Vector3(1, 0, 0), new THREE.Vector3(-1, 0, 0),
                new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, -1, 0),
                new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1)
            ];
            for (const block of blocks) {
                for (const dir of directions) {
                    const neighbor = new THREE.Vector3().copy(block.position).add(dir.multiplyScalar(blockSize));
                    if (neighbor.equals(position)) return true;
                }
            }
            return false;
        }

        // Block placement and removal
        window.addEventListener('mousedown', (event) => {
            const mouse = new THREE.Vector2(
                (event.clientX / window.innerWidth) * 2 - 1,
                -(event.clientY / window.innerHeight) * 2 + 1
            );
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(scene.children);
            if (intersects.length > 0) {
                const intersect = intersects[0];
                const position = new THREE.Vector3().copy(intersect.point).add(intersect.face.normal).divideScalar(blockSize).floor().multiplyScalar(blockSize);

                if (event.button === 0) {
                    if (isAdjacent(position)) {
                        const newBlock = new THREE.Mesh(
                            blockGeometry,
                            new THREE.MeshStandardMaterial({ color: currentBlockColor })
                        );
                        newBlock.position.copy(position);
                        scene.add(newBlock);
                        blocks.push(newBlock);
                    }
                } else if (event.button === 2) {
                    const object = intersect.object;
                    if (object !== platform) {
                        scene.remove(object);
                        const index = blocks.indexOf(object);
                        if (index !== -1) blocks.splice(index, 1);
                    }
                }
            }
        });

        // Keydown for movement (WASD)
        document.addEventListener('keydown', (event) => {
            const speed = 0.2;
            switch(event.key) {
                case 'w':
                    direction.z = -1;
                    break;
                case 's':
                    direction.z = 1;
                    break;
                case 'a':
                    direction.x = -1;
                    break;
                case 'd':
                    direction.x = 1;
                    break;
                case '1': // Change block color to red
                    currentBlockColor = blockColors[0];
                    break;
                case '2': // Change block color to orange
                    currentBlockColor = blockColors[1];
                    break;
                case '3': // Change block color to yellow
                    currentBlockColor = blockColors[2];
                    break;
                case '4': // Change block color to green
                    currentBlockColor = blockColors[3];
                    break;
                case '5': // Change block color to blue
                    currentBlockColor = blockColors[4];
                    break;
                case '6': // Change block color to indigo
                    currentBlockColor = blockColors[5];
                    break;
                case '7': // Change block color to pink
                    currentBlockColor = blockColors[6];
                    break;
            }
        });

        document.addEventListener('keyup', (event) => {
            switch(event.key) {
                case 'w':
                case 's':
                    direction.z = 0;
                    break;
                case 'a':
                case 'd':
                    direction.x = 0;
                    break;
            }
        });

        // Save level functionality (as a .dat file)
        document.getElementById('saveButton').addEventListener('click', () => {
            const levelData = blocks.map(block => ({
                x: block.position.x,
                y: block.position.y,
                z: block.position.z,
                color: block.material.color.getHexString()
            }));

            const zip = new JSZip();
            zip.file("level.json", JSON.stringify(levelData, null, 2));
            zip.generateAsync({ type: "blob" }).then(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'level.dat';
                a.click();
                URL.revokeObjectURL(url);
            });
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Move the camera based on the direction
            velocity.x += direction.x * 0.1;
            velocity.z += direction.z * 0.1;

            camera.position.x += velocity.x;
            camera.position.z += velocity.z;

            // Render the scene
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
