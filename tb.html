<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Three Block</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
        #saveButton {
            position: absolute;
            top: 10px;
            left: 10px;
            padding: 10px 20px;
            background-color: #0078D7;
            color: white;
            border: none;
            cursor: pointer;
            font-size: 16px;
        }
        #saveButton:hover {
            background-color: #005fa3;
        }
    </style>
</head>
<body>
    <button id="saveButton">Save Level</button>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const blockSize = 3;

        // Platform
        const platformGeometry = new THREE.BoxGeometry(blockSize, blockSize / 2, blockSize);
        const platformMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00 });
        const platform = new THREE.Mesh(platformGeometry, platformMaterial);
        platform.position.set(0, -blockSize / 4, 0);
        scene.add(platform);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 1);
        pointLight.position.set(10, 10, 10);
        scene.add(pointLight);

        // Blocks
        const blockGeometry = new THREE.BoxGeometry(blockSize, blockSize, blockSize);
        const blockColors = [0xff0000, 0xff7f00, 0xffff00, 0x00ff00, 0x0000ff, 0x4b0082, 0xff1493];
        let currentBlockColor = blockColors[0];
        const blocks = [platform];

        // Player setup
        camera.position.set(0, blockSize, 5);
        camera.lookAt(0, 0, 0);

        // Orbit controls
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.target.set(0, 0, 0);
        controls.update();

        // Block placement helper
        function isAdjacent(position) {
            const directions = [
                new THREE.Vector3(1, 0, 0), new THREE.Vector3(-1, 0, 0),
                new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, -1, 0),
                new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1)
            ];
            for (const block of blocks) {
                for (const dir of directions) {
                    const neighbor = new THREE.Vector3().copy(block.position).add(dir.multiplyScalar(blockSize));
                    if (neighbor.equals(position)) return true;
                }
            }
            return false;
        }

        // Block interaction
        window.addEventListener('mousedown', (event) => {
            const mouse = new THREE.Vector2(
                (event.clientX / window.innerWidth) * 2 - 1,
                -(event.clientY / window.innerHeight) * 2 + 1
            );
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            const intersects = raycaster.intersectObjects(scene.children);
            if (intersects.length > 0) {
                const intersect = intersects[0];
                const position = new THREE.Vector3().copy(intersect.point).add(intersect.face.normal).divideScalar(blockSize).floor().multiplyScalar(blockSize);

                if (event.button === 0) {
                    if (isAdjacent(position)) {
                        const newBlock = new THREE.Mesh(
                            blockGeometry,
                            new THREE.MeshStandardMaterial({ color: currentBlockColor })
                        );
                        newBlock.position.copy(position);
                        scene.add(newBlock);
                        blocks.push(newBlock);
                    }
                } else if (event.button === 2) {
                    const object = intersect.object;
                    if (object !== platform) {
                        scene.remove(object);
                        const index = blocks.indexOf(object);
                        if (index !== -1) blocks.splice(index, 1);
                    }
                }
            }
        });

        document.addEventListener('keydown', (event) => {
            const blockIndex = parseInt(event.key, 10) - 1;
            if (blockIndex >= 0 && blockIndex < blockColors.length) {
                currentBlockColor = blockColors[blockIndex];
            }
        });

        document.getElementById('saveButton').addEventListener('click', () => {
            const levelData = blocks.map(block => ({
                x: block.position.x,
                y: block.position.y,
                z: block.position.z,
                color: block.material.color.getHexString()
            }));

            const zip = new JSZip();
            zip.file("level.json", JSON.stringify(levelData, null, 2));
            zip.generateAsync({ type: "blob" }).then(blob => {
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'level.dat';
                a.click();
                URL.revokeObjectURL(url);
            });
        });

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>
